name: ArgoCD FIPS-Compliant Build
# Simplified workflow for building secure, FIPS-compliant ArgoCD containers

on:
  workflow_call:
  workflow_dispatch:
  push:
    paths:
      - 'projects/argocd/**'
      - 'patches/argocd/**'
      - 'scripts/**'

env:
  # Project configuration - easy for LLMs to understand
  PROJECT_NAME: "argocd"
  UPSTREAM_REPO: "https://github.com/argoproj/argo-cd.git"
  UPSTREAM_VERSION: "v3.0.11"
  ARGOCD_VERSION: "v3.0.11-mailknight"
  GO_VERSION: "1.24.4"
  NODE_VERSION: "18"
  
  # Security and FIPS compliance
  FIPS_ENABLED: "true"
  OPENSSL_FORCE_FIPS_MODE: "1"
  GOLANG_FIPS: "1"
  CGO_ENABLED: "1"
  
  # Build hardening (security flags)
  CFLAGS: "-fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIE -O2"
  CXXFLAGS: "-fstack-protector-strong -D_FORTIFY_SOURCE=2 -fPIE -O2"
  LDFLAGS: "-Wl,-z,relro,-z,now -pie"
  CGO_CFLAGS: "-fstack-protector-strong -D_FORTIFY_SOURCE=2 -O2"
  CGO_LDFLAGS: "-Wl,-z,relro,-z,now"
  
  # Tools versions
  SYFT_VERSION: "0.100.0"
  TRIVY_VERSION: "0.48.3"
  
  # Build reproducibility
  SOURCE_DATE_EPOCH: "1672531200"  # 2023-01-01

jobs:
  # Consolidated build job - fetch, patch, build all in one
  build-all-components:
    runs-on: ubuntu-latest
    outputs:
      components: ${{ steps.components.outputs.list }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build all ArgoCD components in single job
        run: |
          echo "üöÄ Starting consolidated ArgoCD build process..."
          docker run --rm \
            -v "$GITHUB_WORKSPACE:/workspace" \
            -w /workspace \
            -e PROJECT_NAME="$PROJECT_NAME" \
            -e UPSTREAM_VERSION="$UPSTREAM_VERSION" \
            -e GO_VERSION="$GO_VERSION" \
            -e NODE_VERSION="$NODE_VERSION" \
            -e SYFT_VERSION="$SYFT_VERSION" \
            -e CGO_ENABLED="$CGO_ENABLED" \
            -e CFLAGS="$CFLAGS" \
            -e CXXFLAGS="$CXXFLAGS" \
            -e LDFLAGS="$LDFLAGS" \
            -e CGO_CFLAGS="$CGO_CFLAGS" \
            -e CGO_LDFLAGS="$CGO_LDFLAGS" \
            -e OPENSSL_FORCE_FIPS_MODE="$OPENSSL_FORCE_FIPS_MODE" \
            -e GOLANG_FIPS="$GOLANG_FIPS" \
            -e SOURCE_DATE_EPOCH="$SOURCE_DATE_EPOCH" \
            registry.access.redhat.com/ubi8/ubi-minimal:latest \
            sh -c '
              echo "üì¶ Installing build dependencies..."
              microdnf update -y
              microdnf install -y git wget curl ca-certificates gcc gcc-c++ make nodejs npm tar gzip python3 python3-pyyaml findutils file
              
              echo "üé≤ Generating entropy for SSL operations..."
              # Generate entropy for SSL operations to fix curl randomness issues
              dd if=/dev/urandom of=/dev/random count=1 bs=1024 2>/dev/null
              # Set SSL environment variables for better entropy handling
              export SSL_CERT_DIR=/etc/pki/tls/certs
              export OPENSSL_CONF=/etc/pki/tls/openssl.cnf
              
              echo "üîß Installing Go ${GO_VERSION}..."
              GO_URL="https://go.dev/dl/go${GO_VERSION}.linux-amd64.tar.gz"
              # Use wget as fallback if curl fails with entropy issues
              if ! curl -fsSL "$GO_URL" | tar -xz -C /usr/local; then
                echo "‚ö†Ô∏è  curl failed, trying wget..."
                wget -qO- "$GO_URL" | tar -xz -C /usr/local
              fi
              export PATH="/usr/local/go/bin:$PATH"
              go version
              
              echo "üîç Installing Syft for SBOM generation..."
              # Use wget as fallback for Syft installation
              if ! curl -sSfL https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin v${SYFT_VERSION}; then
                echo "‚ö†Ô∏è  curl failed for Syft, trying wget..."
                wget -qO- https://raw.githubusercontent.com/anchore/syft/main/install.sh | sh -s -- -b /usr/local/bin v${SYFT_VERSION}
              fi
              
              git config --global --add safe.directory /workspace
              
              echo "üì• Step 1: Fetching upstream ArgoCD source..."
              chmod +x scripts/fetch-upstream.sh
              scripts/fetch-upstream.sh ${PROJECT_NAME} ${UPSTREAM_VERSION}
              
              echo "üîß Step 2: Applying Mailknight security patches..."
              chmod +x scripts/apply-patches.sh
              scripts/apply-patches.sh ${PROJECT_NAME} ${UPSTREAM_VERSION}
              
              echo "üèóÔ∏è  Step 3: Building all ArgoCD binaries..."
              chmod +x scripts/build-project.sh
              scripts/build-project.sh ${PROJECT_NAME}
              
              echo "‚úÖ All ArgoCD components built successfully!"
            '

      - name: Set component list for matrix
        id: components
        run: |
          # Define all ArgoCD components for later processing
          echo "list=[\"server\", \"repo-server\", \"application-controller\", \"applicationset-controller\", \"dex\", \"notification\"]" >> $GITHUB_OUTPUT

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: argocd-build-complete
          path: |
            build/
            source/
            sbom.json
          retention-days: 1

  # Test and scan all components - simplified matrix approach  
  test-and-scan:
    runs-on: ubuntu-latest
    needs: build-all-components
    strategy:
      matrix:
        component: ${{ fromJson(needs.build-all-components.outputs.components) }}
      fail-fast: false  # Continue testing other components if one fails
      
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: argocd-build-complete
          path: .

      - name: Build and test component container
        run: |
          echo "üê≥ Building and testing ${{ matrix.component }} container..."
          
          # Define Dockerfile mapping for each component
          case "${{ matrix.component }}" in
            "server") DOCKERFILE="Dockerfile.server" ;;
            "repo-server") DOCKERFILE="Dockerfile.repo-server" ;;
            "application-controller") DOCKERFILE="Dockerfile.controller" ;;
            "applicationset-controller") DOCKERFILE="Dockerfile.applicationset-controller" ;;
            "dex") DOCKERFILE="Dockerfile.dex" ;;
            "notification") DOCKERFILE="Dockerfile.notification" ;;
          esac
          
          # Generate entropy to fix SSL issues  
          echo "üé≤ Generating entropy for SSL operations..."
          sudo dd if=/dev/urandom of=/dev/random count=1 bs=1024 2>/dev/null
          # Install available entropy tools
          sudo apt-get update -qq
          sudo apt-get install -y rng-tools || echo "rng-tools not available, using alternatives"
          
          # Install Docker for container operations
          echo "üê≥ Installing Docker..."
          # Use alternative Docker installation method to avoid curl SSL issues
          if ! curl -fsSL https://get.docker.com -o get-docker.sh; then
            echo "‚ö†Ô∏è  curl failed, trying wget for Docker installation..."
            wget -qO get-docker.sh https://get.docker.com
          fi
          sudo sh get-docker.sh
          sudo usermod -aG docker $USER
          sudo systemctl start docker
          
          # Build container directly on host (simplified approach)
          chmod +x scripts/build-container.sh
          scripts/build-container.sh ${PROJECT_NAME} ${UPSTREAM_VERSION} ${{ matrix.component }} $DOCKERFILE
          
          # Install and run Trivy for security scanning
          echo "üîç Installing Trivy scanner..."
          TRIVY_URL="https://github.com/aquasecurity/trivy/releases/download/v${TRIVY_VERSION}/trivy_${TRIVY_VERSION}_Linux-64bit.tar.gz"
          # Use wget as fallback if curl fails
          if ! curl -sL "$TRIVY_URL" | tar -xz -C /tmp; then
            echo "‚ö†Ô∏è  curl failed, trying wget for Trivy..."
            wget -qO- "$TRIVY_URL" | tar -xz -C /tmp
          fi
          sudo mv /tmp/trivy /usr/local/bin/trivy
          chmod +x /usr/local/bin/trivy
          
          echo "üîç Scanning ${{ matrix.component }} for vulnerabilities..."
          chmod +x scripts/scan-image.sh
          scripts/scan-image.sh ${PROJECT_NAME} ${UPSTREAM_VERSION} ${{ matrix.component }}
          
          echo "üõ°Ô∏è  Testing ${{ matrix.component }} FIPS compliance..."
          chmod +x scripts/test-fips-compliance.sh
          scripts/test-fips-compliance.sh ${PROJECT_NAME} ${UPSTREAM_VERSION} ${{ matrix.component }}
          
          echo "‚úÖ ${{ matrix.component }} container built, scanned, and tested successfully!"

      - name: Upload component artifacts
        uses: actions/upload-artifact@v4
        with:
          name: argocd-${{ matrix.component }}-results
          path: |
            images/${{ matrix.component }}/
            scan-results/${{ matrix.component }}/
            test-results/${{ matrix.component }}/
            image-sbom-${{ matrix.component }}.json
          retention-days: 7

      - name: Upload security scan results to GitHub
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: scan-results/${{ matrix.component }}/trivy-container.sarif
          category: ${{ matrix.component }}-security
        continue-on-error: true

  # Release artifacts (only on tags or manual dispatch)
  release:
    runs-on: ubuntu-latest
    needs: [build-all-components, test-and-scan]
    if: startsWith(github.ref, 'refs/tags/v') || github.event_name == 'workflow_dispatch'
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        
      - name: Download all component results
        uses: actions/download-artifact@v4
        
      - name: Create release artifacts
        run: |
          echo "üì¶ Creating ArgoCD release artifacts..."
          docker run --rm \
            -v "$GITHUB_WORKSPACE:/workspace" \
            -w /workspace \
            -e PROJECT_NAME="$PROJECT_NAME" \
            -e UPSTREAM_VERSION="$UPSTREAM_VERSION" \
            registry.access.redhat.com/ubi8/ubi-minimal:latest \
            sh -c '
              microdnf update -y
              microdnf install -y git python3 python3-pyyaml findutils tar
              git config --global --add safe.directory /workspace
              
              echo "üè∑Ô∏è  Preparing release for ${PROJECT_NAME} ${UPSTREAM_VERSION}..."
              chmod +x scripts/release-artifacts.sh
              scripts/release-artifacts.sh ${PROJECT_NAME} ${UPSTREAM_VERSION}
              
              echo "‚úÖ Release artifacts created successfully!"
            '
        
      - name: Upload release artifacts
        uses: actions/upload-artifact@v4
        with:
          name: argocd-release-complete
          path: releases/
          retention-days: 30